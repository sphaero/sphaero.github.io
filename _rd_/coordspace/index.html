<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <meta name="description" content="" />
    <!-- Bootstrap -->
    <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

    <!-- Custom styles -->
    <style type="text/css">
        body {
            color: #DDD;
            background-color: #455c63;
            background: -webkit-linear-gradient(#6e929e, #455c63); /* For Safari 5.1 to 6.0 */
            background: -o-linear-gradient(#6e929e, #455c63); /* For Opera 11.1 to 12.0 */
            background: -moz-linear-gradient(#6e929e, #455c63); /* For Firefox 3.6 to 15 */
            background: linear-gradient(#6e929e, #455c63); /* Standard syntax */
            font-family: "Lucida Console", Monaco, monospace;
            height: 100%;
        }
        a, a:hover, a:visited {
            color: #BAA39C;
        }
        a:hover {
            text-decoration: underline;
        }
        h1, h2, h3, h4, h5, h6, caption, legend {
            font-weight: bold;
            color: #BAA39C;
        }
        p { 
            text-align: justify;
        }
        .navbar {
            margin-bottom: 0px;
            border: none;
            border-radius: 0px;
            min-height: 10px;
        }
        .navbar-nav li a {
            padding: 4px 10px;
        }
        .navbar-brand {
            height: 10px;
            padding: 4px 10px;
        }
        .navbar-default .navbar-nav > .active {
            color: #000;
            background: #d65c14;
        }
        .navbar-default .navbar-nav > .active > a, 
        .navbar-default .navbar-nav > .active > a:hover, 
        .navbar-default .navbar-nav > .active > a:focus {
            color: #fff;
            background: #455c63;
            border-bottom: #6e929e 1px solid;
            border-top: #6e929e 1px solid;
        }
    </style>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script>
    function appie_kickstart() 
    {
        jQuery.getJSON("all.json", function(data) {
            console.log("got all.json");
            JSONDATA = data;
            var location = window.location.href.split('#')[1] || "";
            setInterval(img_slider, 3000);
            appie_route('#'+location);
        }).error(function(e) {
            console.log("error getting all.json");
            console.log(e);
        });
        $('#main_container img').addClass('img-responsive');
    }
    </script>
  </head>
<body>
<nav id="myNavbar" class="navbar navbar-default navbar-inverse" role="navigation">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbarCollapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" appie_key="home.textile" href="#" onclick="return appie_click(event);"><img src=""/></a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="nav navbar-nav">
                <li><a appie_key="projects" href="/#projects" class="appie_a">projects</a></li>
                <li><a appie_key="_rd_" href="/#_rd_" class="appie_a">r&d</a></li>
                <!--<li><a appie_key="blog" href="#blog" class="appie_a">blog</a></li>-->
                <li><a appie_key="about.textile" href="/#about" class="appie_a">about</a></li>
            </ul>
        </div>
    </div>
</nav>
<div id="main_container" class="container">
    <div class="row"><div class="col-sm-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3">
    <h1>Homogenizing Physical and Virtual Coordinate Spaces 
</h1>
    <p style="text-align: center;">Arnaud Loonstra, arnaud@sphaero.org, Stichting z25.org
<br />15 August 2015</p>
    <div style="margin: 3em;"><h2 style="text-alight: center;">Abstract</h2>
    <p>In this paper we argue for a unification of coordinate spaces for use in mixed reality setups. The paper introduces most used coordinate systems and proposes a system for unification based on existing coordinate systems. An example is given at the end of the paper.
</p></div>
    	<h2>1. Introduction</h2>

	<p>Our environment is nowadays filled with technology. Mobile phones, smart watches, game interfaces, sensors, camera&#8217;s, rfid, etc. This means all this technology can somehow relate to the physical realm. However there are no standards for mapping a physical realm to a digital/virtual realm. One can create a mapping like one needs. However when the amount of devices grows this can be a challenging task. You hope you chose a sensible and flexible mapping set for every device. Apart from making it work it would be more beneficial if the mapping is &#8216;making sense&#8217;. If coordinate systems would not map 1 on 1 then for every change one would need to think about the translation from one coordinate system into the other. This is unintuitive, error prone and making adoption of a clear mental model more difficult. <br />
In this document we outline the results of our research into homogenizing different coordinates systems from the physical and digital realm. We propose a mapping system to homogenize the realm&#8217;s coordinate systems. The proposed mapping is tested for use in the <span class="caps">ZOCP</span> protocol<sup class="footnote" id="fnreve9ef13d1da8949e49445b4785a4b1490"><a href="#fne9ef13d1da8949e49445b4785a4b1490">1</a></sup>.</p>

	<h2>2. What is a coordinate system</h2>

	<p>A coordinate system is a numbering system to uniquely determine a position in a space. A simple example of coordinate system is a position on a line. When an origin, position 0, is determined we can relate the position of any unique point on that line to a positive or negative number. <br />
When we want to determine a position on a plane we need to add another line to determine the position using 2 numbers. We call this a 2 dimensional coordinate system. <br />
We can repeat this to position into 3 dimensions. This can continue indefinitely. However in our physical presence we are used to a three dimensional space. Sometimes we add time as a fourth dimensional coordinate. It is important to understand that the limitation of our physical presence to 3 dimensions is not valid for mathematical spaces. <br />
Besides describing linear positions we can also define angular positions which are usually used for describing orientations. Just think about a compass. It defines North, South, East and West directions. It also defines this as numbers North being 0 degrees and South being 180 degrees. Again this can be repeated to multiple orientation dimensions. We will describe this in detail in this paper.</p>

	<h2>3. Physical coordinate systems</h2>

	<p>In our daily life we are used to many different coordinate systems. When we drive our car to work we are used to kilometers in most countries but in others miles might be used. When sail a ship we will probably use nautical miles and perhaps when we are flying to another planet we are talking about light years. All these coordinate systems are essentially the same. They only differ in the units they use. We will describe the most used coordinate systems and reason why we chose to use them.</p>

	<h3>3.1. Metric System</h3>

	<p>The Metric System<sup class="footnote" id="fnrev54e6624dd3914656aa77fdbb3731b164"><a href="#fn54e6624dd3914656aa77fdbb3731b164">2</a></sup> is a system introduced by the French in 1799. Nowadays it is also used under the synonym “SI” or “International System of Units”. It is officially the most used measuring system in almost all countries. This is also the most profound reason why we chose to adopt this system as a standard for mapping physical and virtual realms. The only countries that do not use the metric system are America, Liberia and Myanmar(Burma). <br />
The foundations of the metric system are the &#8216;meter&#8217; and the &#8216;kilogram&#8217;. The metric system was designed to be universal and based on natural phenomena. For example one meter was initially defined to be one ten millionth of the distance from the equator to the North Pole through Paris. A kilogram was defined as the mass of 1/1000th of a cubic meter of pure water at its melting point. Future developments showed more accurate ways to determine a meter&#8217;s length and by 1983 a meter was defined by the constant of the speed of light. <br />
It is important to realize that these metric units are based on natural reproducible facts. Many other units are based on the metric system and therefore show coherence. We will show later that this is important for the digital realm as well. Since the metric system enjoys broad adoption we will adopt this system as a foundation.<br />
In 1999 the $125 million dollar Mars Climate Orbiter crashed into Mars because the American spacecraft engineers calculated using American units while the thrust engineers were expecting units specified in the metric system. This is illustrates the importance of having agreed standards hence this research.</p>

	<h3>3.2. Orientation</h3>

	<p>The most common orientation system is the compass bearing. It was invented somewhere around 200BC and we are still using the North, South, East, West orientations today. The compass bearing describes a single dimensional orientation using degrees as an angular unit. It is unknown how the degree unit originated and what it is based on. The degree is not an SI unit. It is however mentioned as a &#8216;accepted&#8217; unit. The official unit in SI is a &#8216;radian&#8217;. The radian is a more practical unit since it is easier to use for mathematical operations. The radian is defined as being the length of half a circle with a radius of 1. So if you take half a circle with a one meter radius the length of this half circle will be 1 radian which is 3.1415926535&#8230; meter. This is the famous Pi (π) number. Illustration 3 is a chart consisting of different angular coordinates and show how to convert between them. <br />
Ever since we are looking up to the stars we know that a compass bearing orientation is not enough to describe our orientation. There are at least three units needed to describe our orientation. These are often called yaw, pitch and roll and stem from Euler Angles. Other system might refer to these as heading, pitch and bank. As both define pitch this can de the source of confusion hence we discard this notation. <br />
An Euler Angle has its limitations. Imagine turning to an orientation with the maximum values. Now try turning beyond that orientation. This called the &#8216;Gimbal Lock&#8217;. Because of the &#8216;Gimbal Lock&#8217; quaternion orientation might be suited better. As Quaternions are very mathematical we only mention their existence as a coordinate orientation and will not elaborate further<sup class="footnote" id="fnrev179eed9958bf40cdbb056fbb4bfca0b4"><a href="#fn179eed9958bf40cdbb056fbb4bfca0b4">3</a></sup>.</p>

	<h3>3.3. Time</h3>

	<p>Time is one of the seven fundamentals in the metric system (SI). Time is used to describe the order of events from past to present to future. It is thus a one dimensional coordinate system. A time unit in the metric system is defined as a second. Initially time was determined by the cycle of the moon and the sun but nowadays a second is defined in terms of radiation emitted by caesium atoms.</p>

	<h3>3.4. Positioning on earth</h3>

	<p>A coordinate system known by many because of its adoption by navigations devices using the Global Positioning System (<span class="caps">GPS</span>) is called <span class="caps">WGS</span>84<sup class="footnote" id="fnrev05f3f4c523824ba5bce2625d96bc9450"><a href="#fn05f3f4c523824ba5bce2625d96bc9450">4</a></sup>. It was established in 1984 and its latest revision is of 2004. <span class="caps">WGS</span>84 is a coordinate system to describe any location on earth with a 2cm accuracy.  It is important to understand that <span class="caps">WGS</span>84 is a 2D coordinate system on a mathematical sphere. This means it can never describe the height of your position. As <span class="caps">WGS</span>84, through the <span class="caps">GPS</span> system, has broad adoption it would be unwise to not adopt it. However it is wise to look further as one could imagine doing something outside of earths boundaries (e.g. satellites, space probes). Some alternatives to <span class="caps">WGS</span>84 are the European Terrestrial Reference System 1989 and North American Datum 1983 however these have the same shortcoming as <span class="caps">WGS</span>84. The International Astronomical Union (<span class="caps">IAU</span>) has adopted the International Celestial Reference System (<span class="caps">ICRS</span>). <span class="caps">ICRS</span> is a high precision positional coordinate system. It has its origin (position 0,0,0) at the solar system barycenter. This would be an ideal reference coordinate system. On the other hand to use it practically will be very hard because of the simple fact that our planet earth is flying around the sun at an incredible speed. Any <span class="caps">ICRS</span> coordinate on earth would be subject to a constant change and a fixed position depends on time. So to remain practical we would adopt the common coordinate system used by <span class="caps">GPS</span> receivers, but to remain ambitious we would adopt the <span class="caps">ICRS</span> coordinate system</p>

	<h2>4. Virtual coordinate systems</h2>

	<p>The virtual or digital realm is essentially an abstraction. Inside the computer there is no such thing as a virtual reality that can be regarded as the physical reality. The virtual reality can computationally simulate a physical reality in 3 dimensions but since it is an abstraction the computer can continue beyond three dimensions. However for our purposes of mapping a physical reality to a virtual reality three dimension will do fine. We will look into coordinate systems similar to those in the physical realm used in the digital realms. As most of our digital realities are related to OpenGL it might be sensible to follow its approach as close as possible. </p>

	<h3>4.1. OpenGL</h3>

	<p>The most used functionality of OpenGL is to translate a three dimensional scene into a two dimensional representation. This is basically what happens when you are playing a 3D game on your monitor. OpenGL defines several coordinate spaces to support converting a 3d space into a 2d representation. However OpenGL, being a general purpose language, does not dictate any standard into mapping a physical coordinate space to a virtual. It therefore provides any desired way hence our need to settle on one approach to prevent dealing with different interpretations. <br />
OpenGL defines “Object Space”. Three-dimensional objects are defined a coordinate space convenient for describing the object&#8217;s properties (vertices, normals etc). Or to put in layman&#8217;s terms; in case of a pyramid the 5 points (4 bottom, 1 top) of the pyramid are described in “Object Space” coordinates.<br />
To see this pyramid in a context of a scene OpenGL defines “World Space”. The pyramid&#8217;s location is described in “World Space” coordinates. <br />
In order for the pyramid&#8217;s position to be described in this space it needs an &#8216;origin&#8217; point. The origin point is described in the object&#8217;s “Object Space”. To understand this from a physical perspective imagine you are holding the pyramid in your hand. The exact position where you are holding the pyramid is the pyramid&#8217;s origin.<br />
OpenGL has a notion of &#8216;units&#8217;. However, if an object has a size of 3 units this could mean anything. Is a unit a meter, a millimeter, a lightyear?  To OpenGL this is unimportant however if one wants to relate to our physical space in an absolute way we need to specify what a &#8216;unit&#8217; is. In OpenGL a unit can be different in every coordinate space. Suppose your pyramid has a unit size of 1 centimeter. In openGL it is possible to define “World Space” in meters. In order to have a correct representation of the pyramid we need to transform the “Object Space” coordinate system into the “World Space” coordinate system. In OpenGL this is called “Model Transformation”. In our example we need to scale the “Object Space” coordinate system by a factor of 10 to match it to “World Space” coordinates. In OpenGL the “Model Transformation Matrix” describes this transformation.   It is called a “Matrix” since the transformation between coordinate space is done using mathematical matrices. To understand this fully you have to understand linear algebra. However, at least remember that matrix calculation is used to transform from one coordinate space to another.<br />
Finally in case we are displaying this openGL setup we need to transform “World Space” into “Eye Space”. This is similar to “Object Space” transformation thus described in the “View Matrix”. To imagine this you need just need to think of the camera filming the scene. The camera has a position, orientation, etc in “World Space” coordinates. To display a scene through the camera all coordinates must be described in coordinate space of the camera.<br />
To map the OpenGL coordinate system to a physical coordinate system we need to take some physical properties into account. We all know that when we hold a apple in the air and let go it will drop. You should know that this is how Newton discovered the basic laws of gravitation. The apple will fall to the floor with an acceleration of 9.81 m/s2. Suppose we would want to simulate this in openGL. We could write our own methods to simulate dropping an apple but we will probably use a physics engine as we don&#8217;t want to reinvent the wheel. A physics engine simulates essential properties of the physical realm. It would make sense to make use of the same gravitational laws as we have in the physical realm. Since we will probably remain on earth most of the time it makes sense to use the acceleration value of 9.81 m/s2. This implies we are calculating in meters. Therefore it makes sense to set an OpenGL unit to 1 meter as well to guarantee numbers remain the same. It is convenient to have equal number so we don&#8217;t have to transform numbers for each coordinate system. <br />
Finally we need to define what is the positive direction and what negative. There are actually two main coordinate systems: Right-Handed and Left-Handed. Why those names? 
	<ul>
		<li>1. Stretch your right arm and form a 90 degree angle with your elbow</li>
		<li>2. Point your right hand thumb to the right side</li>
		<li>3. Point your right hand finger up</li>
		<li>4. Point your right hand middle finger in your direction<br />
This is the Right-handed coordinate system. Your fingers are now pointing in the positive direction. <br />
OpenGL uses the Right-Handed system. Obviously if you would do this with your left hand you would get the Left-Handed system.<br />
Actually we haven&#8217;t set this for our physical coordinate system either. To match directions in the physical realm we have to face north. By this the <span class="caps">RHS</span> will be valid for the physical realm as well as this matches <span class="caps">WGS</span>84 directions. <br />
We now have described the coordinate systems of OpenGL we need. We have “World Space” coordinates to define the location of every object in our world. We have “Object Space” coordinates to define the dimensional properties of an individual object. Why two sets of coordinates? Imagine your newly bought <span class="caps">DIY</span> construction cupboard. If you are constructing the cupboard you are not thinking of how it is constructed in dimensional terms of your living room. The manufacturer also cannot give you instructions based on the dimensions of your living room because of the simple fact that the manufacturer doesn&#8217;t know the dimensions of your living room.</li>
	</ul></p>

	<h3>4.2. Digital Time</h3>

	<p>Time in a computer is a more complicated coordinate than in the physical realm. If you switch a computer off it has no notion of time. If you power it on it cannot know what time it is. For the computer time is a very relative coordinate. The only way it can determine a time unit is by its cpu clock. However this is not the most stable reference and often causes drift. Therefore most computers are equipped with an on-board clock. This clock ticks even if your computer is off. Even then time is unreliable as it must be set manually. Networked computers are able synchronize their clocks using a protocol like the Network Time Protocol (<span class="caps">NTP</span>)<sup class="footnote" id="fnrevc9a869200c664357b6c8be08ea14a85f"><a href="#fnc9a869200c664357b6c8be08ea14a85f">5</a></sup>. This protocol ensures the computers have their clocks synchronized with maximally a few milliseconds drift. However without an external source time can still not be reliably mapped onto physical time. On internet a hierarchy of <span class="caps">NTP</span> servers provide a reliable source to synchronize clocks with. The <span class="caps">GPS</span> system (<span class="caps">WGS</span>84) also provides a very reliable time signal with an accuracy of +-10 nanoseconds. </p>

	<h2>5. Mapping physical coordinates to virtual</h2>

	<p>We believe that having a sensible coordinate systems improves workflow when working in both  realms. As said before transforming coordinates systems is an error prone activity as was illustrated by the crash of the Mars Climate Orbiter. We have experienced situations in which coordinate systems needed translation causing a lot of strain on rapid prototyping developments and situations which demanded improvising. Non-homogenized coordinate systems also proved much harder to debug again straining development progression. If we settle on the coordinate system provided by the metric system and the coordinate systems of OpenGL as described before we can now make a mapping between the physical and virtual realm. <br />
We now describe the used coordinates starting in the physical realm and moving into the virtual realm. We are describing the coordinates as a hierarchy. When you have a chair in a room and you move the room the chair will move along. The relation of the objects is described by this hierarchy.<br />
Our physical setup consists of a room with dimension of 3&#215;4&#215;2 meters (LxWxH) with its origin at <span class="caps">GPS</span> coordinates: 52.1153016,5.1389998. We call this our physical root.</p>

	<p>root:
 <span class="caps">WGS</span>84: (52.1153016, 5.1389998)
 Room: 
  position: (0,0,0)
  dimension: (2.0, 4.0, 2.0)
  orientation: (radians? Euler?)
  matrix: (describes, position, rotation and 
           scale in 9 floats)<br />
Inside the room we put a chair. The chair has a dimension of 60&#215;80&#215;90 (LxWxH) centimeter and is placed in the left corner of the room opposite the origin of the room.
  Chair:    
   position: (1,5, 3.5, 0)
   dimension: (0.6, 0.8, 0.9)
   orientation: (0, 3.14, 0)<br />
Also a television cannot be left out from the room is it already too dull. We place the television in the room facing the chair.
  Television:
   position: (1.0, 2.0, 0.7)
   dimension: (0.8, 0.2, 0,45)
   orientation: (0, -3,0, 0)<br />
A television is an interesting object. The German word (fernseher) can be literally translated as &#8216;seeing far&#8217;. The television is an object that can make us perceive a virtual world by vision. Usually a film displays it&#8217;s own perspective of a virtual world with little respect to the physical space it is displayed in. This is simply not needed for film. Suppose we would place a second television in the room and we would want it to display the same scene from the first television. We want it to respect the perspective the spectator is in. Then the position of the first television, the second television, and the spectators needs to be known. If we need those positions we might as well make sure these positions match the physical space. Matching the physical and the virtual realm&#8217;s coordinates is an essential ingredient for mixing multiple media in multiple realities. We refer to these developments as Mixed Reality.<br />
Since we now have a television which can act as a window to our virtual world we can add our first virtual object. We will add a simple sphere which is hovering in the middle of the room.
  Ball:
   position: (1.0, 2.0, 1.0)
   dimension: (0.2, 0.2, 0.2)
   orientation: (0, 0, 0)<br />
Suppose we would let the ball bounce through the room indefinitely. If this was a physical ball we would be able to see it. However since it is a virtual ball the only way to see it would be through the television. The only moments we would be able to witness the ball through the television would be when the ball would be within the vision line of you (the spectator) and the television. We already know the position of the ball. We know the position of the television. We only don&#8217;t know the position of you. In this scenario we will register the position of your eyes.
  Spectator:
   position: (1.0, 1.0, 1.6)
   dimension: (0.6, 0.3, 1.7)
   orientation: (0, 0, 0)<br />
We can now have enough information to render the ball and display it on the television. A virtual camera will be placed at the exact position of your eyes. It&#8217;s orientation will be perpendicular facing the television and its lens will be shifted so that it exactly matches the frame of the television. You can now see the ball through the television when it moves through the room.</p>

	<h3>5.1. Overview of data:</h3>

	<p>root:
 <span class="caps">WGS</span>84: (52.1153016, 5.1389998)
 Room: 
  position: (0,0,0)
  dimension: (2.0, 4.0, 2.0)
  orientation: (radians? Euler?)
  matrix: (describes, position, rotation and 
           scale in 9 floats)
  Chair: 
   position: (1,5, 3.5, 0)   
   dimension: (0.6, 0.8, 0.9)
   orientation: (0, 3.14, 0)
 Television:
  positition: (1.0, 2.0, 0.7)
  dimension: (0.8, 0.2, 0,45)
  orientation: (0, -3,0, 0)
 Ball:
  position: (1.0, 2.0, 1.0)
  dimension: (0.2, 0.2, 0.2)
  orientation: (0, 0, 0)
 Spectator:
 position: (1.0, 1.0, 1.6)
 dimension: (0.6, 0.3, 1.7)
 orientation: (0, 0, 0)</p>

	<h2>6. Acknowledgments</h2>

	<p>We would like to thank the z25.org Foundation and <span class="caps">MAPLAB</span> of the <span class="caps">HKU</span> University of the Arts for supporting this research. As this research is referring to very common systems and facts we are referring to Wikipedia pages as they are more accessible  in-depth documents than many scientific documents.</p>

	<h2>7. References</h2>

	<p>[1] A. Loonstra, “Orchestrating computer systems, a research into a new protocol,” <span class="caps">FOSDEM</span> 2015 conference, Brussels, 01-Feb-2015. [Online]. Available: https://fosdem.org/2015/schedule/event/deviot02/. [Accessed: 08-Apr-2015].</p>

	<p>[2] “Metric system,” Wikipedia, the free encyclopedia. 15-Jul-2015.</p>

	<p>[3] “Rotation formalisms in three dimensions,” Wikipedia, the free encyclopedia. 07-Jul-2015.</p>

	<p>[4] “World Geodetic System,” Wikipedia, the free encyclopedia. 15-Jun-2015.</p>

	<p>[5] J. Burbank, <> D. M., and <> W. K., “Network Time Protocol Version 4: Protocol and Algorithms Specification.” [Online]. Available: https://tools.ietf.org/html/rfc5905. [Accessed: 15-Jul-2015].</p>
    </div></div>
</div>
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <script>jQuery(document).ready(appie_kickstart());
    </script>
</body>
</html>